/**
 * Intel Summary Component
 *
 * Unified LLM-powered summary that aggregates ALL intel sources:
 * - Community reports (from IndexedDB/Supabase)
 * - Web search results
 * - Weather data
 *
 * Generates ONE concise summary at the top of the Intel page.
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { Sparkles, RefreshCw, AlertCircle, Zap } from 'lucide-react';
import { LLMService } from '@/services/llm';
import { useAppStore, useReportsStore } from '@/stores';
import { isSupabaseConfigured } from '@/lib/supabase';
import { t } from '@/lib/translations';
import type { CommunityReport } from '@/stores/useReportsStore';
import type { ConditionReport } from '@/agents';

interface IntelSummaryProps {
  region: string;
}

// Formatting helpers
const SNOW_LABELS: Record<string, string> = {
  puch: 'puch (powder)',
  firn: 'firn (corn)',
  cukier: 'cukier (sugar snow)',
  szren: 'szreń (crust)',
  beton: 'beton (hard/icy)',
  kamienie: 'kamienie (rocks)',
  mokry: 'mokry śnieg (wet)',
};

const TRACK_LABELS: Record<string, string> = {
  przetarte: 'przetarte (tracked)',
  zasypane: 'zasypane (fresh)',
  lod: 'lód (icy)',
};

function formatCommunityReport(report: CommunityReport): string {
  const date = new Date(report.timestamp).toLocaleDateString('pl-PL', {
    month: 'short',
    day: 'numeric',
  });

  let info = `${report.location} (${date}): `;

  if (report.type === 'ascent' && report.ascent) {
    const track = TRACK_LABELS[report.ascent.trackStatus] || report.ascent.trackStatus;
    info += `Podejście - trasa ${track}`;
    if (report.ascent.gearNeeded.length > 0) {
      info += `, potrzebne: ${report.ascent.gearNeeded.join(', ')}`;
    }
  } else if (report.type === 'descent' && report.descent) {
    const snow = SNOW_LABELS[report.descent.snowCondition] || report.descent.snowCondition;
    info += `Zjazd - ${snow}, ${report.descent.qualityRating}/5`;
  }

  if (report.notes) {
    info += ` "${report.notes.slice(0, 50)}"`;
  }

  return info;
}

function formatWebReport(report: ConditionReport): string {
  const date = new Date(report.reportDate).toLocaleDateString('pl-PL', {
    month: 'short',
    day: 'numeric',
  });

  let info = `${report.location} (${date}, ${report.sourceName}): `;

  if (report.conditions.length > 0) {
    info += report.conditions.join(', ');
  }

  // Include raw snippet if it has useful info
  if (report.summary && report.summary.length > 20) {
    // Extract key terms, avoid full summary that might be LLM-generated
    const shortSnippet = report.summary.slice(0, 80).replace(/\n/g, ' ');
    info += ` - "${shortSnippet}"`;
  }

  return info;
}

export function IntelSummary({ region }: IntelSummaryProps) {
  const [summary, setSummary] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [autoGenerated, setAutoGenerated] = useState(false);
  const hasAttemptedAuto = useRef(false);

  const { webReports, weather } = useAppStore();
  const { getRecentReports } = useReportsStore();

  // Check if LLM is available (Supabase configured)
  const llmAvailable = isSupabaseConfigured();

  // Get all data
  const communityReports = getRecentReports(48).filter(
    (r) =>
      r.region.toLowerCase().includes(region.toLowerCase()) ||
      region.toLowerCase().includes(r.region.toLowerCase())
  );

  const hasData = communityReports.length > 0 || webReports.length > 0;

  const generateSummary = useCallback(async () => {
    if (!hasData) {
      setError(t.intel.noData);
      return;
    }

    if (!llmAvailable) {
      setError(t.intel.notAvailable);
      return;
    }

    setIsLoading(true);
    setError(null);

    const llm = new LLMService();

    // Build comprehensive data summary
    const dataSections: string[] = [];

    // Weather context
    if (weather) {
      dataSections.push(
        `AKTUALNA POGODA: ${weather.temperature}°C, ${weather.condition}, wiatr ${weather.windSpeed} km/h`
      );
    }

    // Community reports
    if (communityReports.length > 0) {
      const formatted = communityReports
        .slice(0, 8)
        .map(formatCommunityReport)
        .join('\n');
      dataSections.push(`RAPORTY SPOŁECZNOŚCI (${communityReports.length} łącznie):\n${formatted}`);
    }

    // Web intel
    if (webReports.length > 0) {
      const formatted = webReports
        .slice(0, 5)
        .map(formatWebReport)
        .join('\n');
      dataSections.push(`ŹRÓDŁA INTERNETOWE (${webReports.length} źródeł):\n${formatted}`);
    }

    const dataText = dataSections.join('\n\n');

    // Direct, no-preamble prompt - ask for Polish response
    const userPrompt = `Przeanalizuj dane o warunkach skiturowych dla regionu ${region}, Polska i napisz 2-3 zdania o aktualnych warunkach.

${dataText}

Napisz bezpośrednie podsumowanie zaczynając od informacji o warunkach. BEZ wstępów typu "Oto" czy "Na podstawie". Po prostu podaj warunki.`;

    const systemPrompt = `Jesteś przewodnikiem skiturowym podającym krótką informację o warunkach. Bądź bezpośredni i praktyczny. Zacznij od kluczowych informacji - bez wstępów. Odpowiedz po polsku. Przykład dobrej odpowiedzi: "Świeży puch powyżej 1400m, przetarte trasy poniżej. Uwaga na lód na północnych stokach. Najlepsze warunki dziś na Pilsku."`;

    try {
      const response = await llm.prompt(userPrompt, systemPrompt, {
        signal: AbortSignal.timeout(30000),
      });

      // Clean up response - remove any preamble patterns
      let cleaned = response.trim();
      const preambles = [
        /^(oto|na podstawie|według|aktualnie|podsumowanie:|warunki:)\s*/i,
        /^(warunki skiturowe|aktualne warunki|warunki w)[^.]*:\s*/i,
      ];
      for (const pattern of preambles) {
        cleaned = cleaned.replace(pattern, '');
      }
      // Capitalize first letter
      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);

      setSummary(cleaned);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Nie udało się wygenerować podsumowania';
      if (message.includes('timeout')) {
        setError(t.intel.timeout);
      } else {
        setError(message);
      }
    } finally {
      setIsLoading(false);
    }
  }, [hasData, communityReports, webReports, weather, region, llmAvailable]);

  // Auto-generate on first load if we have data and LLM is available
  useEffect(() => {
    if (hasData && llmAvailable && !summary && !hasAttemptedAuto.current && !isLoading) {
      hasAttemptedAuto.current = true;
      setAutoGenerated(true);
      generateSummary();
    }
  }, [hasData, llmAvailable, summary, isLoading, generateSummary]);

  if (!hasData) {
    return null;
  }

  // Don't show component at all if LLM is not available
  if (!llmAvailable) {
    return null;
  }

  return (
    <div className="bg-gradient-to-r from-purple-900/40 via-blue-900/30 to-purple-900/40 rounded-xl border border-purple-500/30 p-4">
      {/* Header */}
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2">
          <div className="w-8 h-8 rounded-lg bg-purple-500/20 flex items-center justify-center">
            <Sparkles className="w-4 h-4 text-purple-400" />
          </div>
          <div>
            <h3 className="text-sm font-semibold text-white">{t.intel.title}</h3>
            <p className="text-xs text-gray-500">
              {communityReports.length} raportów + {webReports.length} źródeł
            </p>
          </div>
        </div>
        {summary && !isLoading && (
          <button
            onClick={generateSummary}
            className="p-2 hover:bg-white/10 rounded-lg transition-colors"
            title="Odśwież podsumowanie"
          >
            <RefreshCw className="w-4 h-4 text-purple-400" />
          </button>
        )}
      </div>

      {/* Loading state */}
      {isLoading && (
        <div className="flex items-center gap-3 py-2">
          <div className="relative">
            <Zap className="w-5 h-5 text-purple-400 animate-pulse" />
          </div>
          <span className="text-sm text-purple-200">{t.intel.analyzing}</span>
        </div>
      )}

      {/* Error state */}
      {error && !isLoading && (
        <div className="space-y-2">
          <div className="flex items-start gap-2 text-amber-400">
            <AlertCircle className="w-4 h-4 flex-shrink-0 mt-0.5" />
            <span className="text-sm">{error}</span>
          </div>
          <button
            onClick={generateSummary}
            className="text-xs text-purple-400 hover:text-purple-300"
          >
            {t.intel.tryAgain}
          </button>
        </div>
      )}

      {/* Summary display */}
      {summary && !isLoading && (
        <p className="text-sm text-gray-100 leading-relaxed">{summary}</p>
      )}

      {/* Generate button (only if no auto-generation happened) */}
      {!summary && !isLoading && !error && !autoGenerated && (
        <button
          onClick={generateSummary}
          className="w-full py-3 bg-purple-600/30 hover:bg-purple-600/50 rounded-lg text-sm text-purple-200 transition-colors flex items-center justify-center gap-2"
        >
          <Sparkles className="w-4 h-4" />
          {t.intel.generate}
        </button>
      )}
    </div>
  );
}
